#!/bin/bash
#################################################################################
# Pulls the configurations
################################################################################
pull_config(){
	# echo -n "Pulling philconfig configurations : "
	pushd $CONFIG_DIR > /dev/null
	git pull > /dev/null 2>&1
	pull_success=$?
	popd > /dev/null
	if [[ $pull_success != 0 ]]; then
		echo "!! Could not pull pull philconfig !!"
	fi
}

################################################################################
# Uses find to go to a directory that is not in the PWD nor on CDPATH
# If the target is a directory, we go into it, if the target is a file, we go
# into the directory containing the file.
################################################################################
cdf(){
	result="$(find . -name "$1" -print -quit)"
	if [[ -d "$result" ]] ; then
		cd $result
		echo $(pwd) 1>&2
	elif [[ -f "$result" ]] ; then
		cd "$(dirname "$result")"
		echo $(pwd) 1>&2
	elif [[ $result == "" ]]; then
		echo "cdf: nothing found matching $1" 1>&2
	else
		echo "result $result could not be cd'd into" 1>&2
	fi
}

################################################################################
# Git push all branches to repository
################################################################################
pushall(){
	# Todo: upgrade this to prompt for each branch (asking y/n) whether we want
	# to push it.
	if [[ $1 == "" ]]; then
		remote=origin
	else
		remote=$1
	fi
	for b in $(git branch | tr '*' ' '); do
		echo -n "Push branch $b (y/n)? " 1>&2
		read answer
		if [[ "$answer" == y ]] ; then
			git push $remote $b;
		fi
	done
}


################################################################################
# Connects over ssh to school computer of my choice
################################################################################
ssh_school() {
	if [[ $1 == "" ]]; then
		computer="l4712-01"
	else
		computer=$1
	fi
	ssh $computer.info.polymtl.ca -l phcarb -Y
}

################################################################################
# Uses find to go to a directory that is not in the PWD nor on CDPATH
################################################################################
p_valgrind(){
	flags=$3
	cmd=$1
	if [ "$2" != "" ] ; then
		target=$2
	else
		target=~/valgrind.lst
	fi
	valgrind $flags $cmd > $target 2>&1
}


################################################################################
# Follows one level of link indirection.  The target must be a link otherwise
# readlink returns nothing.
################################################################################
cdl () {
	cd "$(dirname "$(readlink "$1")")";
}

################################################################################
# Remove accents from a file in-place (note, only the accented characters that
# would show up in the French language).
################################################################################
accents="âàäêèëéîïôöûùüÿçÂÀÄÊÈËÉÎÏÔÖÛÙÜŸÇ¨"
no_accents="aaaeeeeiioouuuycAAAEEEEIIOOUUUYC "
fremove-accents () {
	file=$1
	if [ -z $file ] ; then
		echo "fremove-accents error: no file specified"
		return
	fi

	if ! [ -e $file -o -L $file ] ; then
		echo "fremove-accents error: file $file doesn't exist"
		return
	fi

	cp $file $file.bak
	tr "$accents" "$no_accents" < $file > $file.removed_accents
}

function cdw (){
    target=$(which $1)
    cd $(dirname $target)
}

git_pwd() {
	if [[ $(git rev-parse --is-inside-work-tree 2>/dev/null) == true ]] ; then
		repo_dir=$(git rev-parse --show-toplevel 2>/dev/null)
		outer=$(basename $repo_dir)
		inner=$(git rev-parse --show-prefix 2>/dev/null)
		echo "${outer}/${inner}"
	else
		echo '\w'
	fi
}

at_cmc() {
    if [ $(whoami) = afsmpca ] ; then
        return $(true)
    else
        return $(false)
    fi
}

at_poly() {
    if [ $(whoami) = phcarb ] ; then
        return $(true)
    else
        return $(false)
    fi
}

################################################################################
# Vim with special arguments
################################################################################
vimw() {
    filepath=$(which $1); shift
    vim $filepath $@
}

longest_common_prefix() {
    # ref https://stackoverflow.com/a/32116308/5795941
    lines="$1"
    prefix="$(echo "$lines" | \grep -zoP '^(.*)(?=.*?\n\1)')"
    echo "$prefix" | tail -1
}

common_dir() {
    lines=$1
    common_text="$(longest_common_prefix "$lines")"
    if [ -d $common_text ] ; then
        common_dir=$common_text
    else
        common_dir=$(dirname $common_text)
    fi
    echo $common_dir
}

vimf() {
    query=$1; shift
    results="$(find . -name "$query")"

    dir=$(common_dir "$results")

    # Go into found directory
    if pushd $dir 2>/dev/null ; then

        # Re-do query from new directory
        new_results="$(find . -name "$query")"

        # Report results
        echo -e "directory=$dir \nfiles="
        echo "$new_results" | sed 's/^/   /g'
        echo "Press any key to continue"
        read

        # Launch vim with these results
        vim $new_results $@
        popd 2>/dev/null
    else
        echo "Could not cd into $common_dir"
    fi
}
